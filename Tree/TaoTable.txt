 <style>
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    th, td {
      border: 1px solid #999;
      padding: 8px;
      text-align: left;
    }
    th {
      background-color: #eee;
    }
    input[type="text"] {
      width: 80%;
      padding: 6px;
      margin-top: 10px;
    }
    label {
      margin-left: 10px;
      font-size: 14px;
    }
  </style>
</head>
<body>

  <input type="text" id="searchInput" placeholder="Tìm kiếm...">
  <label><input type="checkbox" id="andMode"> AND</label>

  <div id="tableContainer"></div>

  <script>
    let originalRows = [];

    function generateTableFromLocalStorage() {
      const raw = localStorage.getItem("tableX");
      if (!raw) return;

      localStorage.removeItem("tableX");
      const rows = raw.trim().split("\n").map(row => row.split("\t"));
      originalRows = rows;
      renderTable(rows);
    }

    function renderTable(rows) {
      const container = document.getElementById("tableContainer");
      container.innerHTML = "";

      if (rows.length === 0) return;

      const table = document.createElement("table");
      const thead = document.createElement("thead");
      const tbody = document.createElement("tbody");

      const headerRow = document.createElement("tr");
      const sttTh = document.createElement("th");
      sttTh.textContent = "STT";
      sttTh.style.width = "5%";
      headerRow.appendChild(sttTh);

      rows[0].forEach(col => {
        const th = document.createElement("th");
        th.textContent = col;
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);

      // Đánh lại STT kể cả sau khi lọc
      let currentStt = 1;

      for (let i = 1; i < rows.length; i++) {
        const tr = document.createElement("tr");

        const sttTd = document.createElement("td");
        sttTd.textContent = currentStt++;
        tr.appendChild(sttTd);

        rows[i].forEach(cell => {
          const td = document.createElement("td");
          td.textContent = cell;
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      }

      table.appendChild(thead);
      table.appendChild(tbody);
      container.appendChild(table);
    }

    function searchTable() {
      const input = document.getElementById("searchInput").value.trim().toLowerCase();
      const andMode = document.getElementById("andMode").checked;
      const keywords = input.split(/\s+/);

      if (!input) {
        renderTable(originalRows);
        return;
      }

      const matchedRows = [originalRows[0]];

      for (let i = 1; i < originalRows.length; i++) {
        const rowText = originalRows[i].join(" ").toLowerCase();
        const match = andMode
          ? keywords.every(k => rowText.includes(k))
          : keywords.some(k => rowText.includes(k));
        if (match) matchedRows.push(originalRows[i]);
      }

      renderTable(matchedRows);
    }

    document.getElementById("searchInput").addEventListener("input", searchTable);
    document.getElementById("andMode").addEventListener("change", searchTable);

    generateTableFromLocalStorage();
  </script>
