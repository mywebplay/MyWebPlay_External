<style>
  body { font-family: Arial, sans-serif; margin: 20px; }
  table { border-collapse: collapse; width: 100%; table-layout: fixed; }
  th, td {
    border: 1px solid #ccc;
    padding: 6px 8px;
    word-wrap: break-word;
    white-space: normal;
    text-align: left;
  }
  th.stt-col, td.stt-col {
    width: 5%;
    text-align: center;
    white-space: nowrap;
  }
  input.search-box {
    width: 100%;
    box-sizing: border-box;
    margin-bottom: 10px;
    padding: 6px 8px;
  }
  .search-row {
    margin-top: 10px;
  }
</style>
</head>
<body>

<div id="tableContainer"></div>
<div id="searchInputs" class="search-row"></div>

<script>
(function(){
  // Lấy dữ liệu raw từ localStorage
  const rawData = localStorage.getItem("tableX") || "";
  // Xóa vĩnh viễn localStorage sau khi lấy
  localStorage.removeItem("tableX");

  if (!rawData.trim()) {
    document.getElementById("tableContainer").innerHTML = '<p><i>Không có dữ liệu để hiển thị</i></p>';
    return;
  }

  // Lưu biến gốc toàn cục để lọc
  window._originalData = rawData;

  // Phân tích dữ liệu raw thành mảng dòng
  const rows = rawData.trim().split(/\r?\n/);

  // Header có định dạng: Text***%Width\tText***%Width\t...
  const headerCols = rows[0].split("\t").map(h => {
    const parts = h.split("***");
    return {
      text: parts[0].trim(),
      width: (parts[1] && !isNaN(parts[1])) ? parseInt(parts[1]) : 0
    };
  });

  // Hàm tạo bảng từ mảng dòng (dữ liệu thô)
  function renderTable(dataRows) {
    const tableContainer = document.getElementById("tableContainer");
    if (dataRows.length <= 1) {
      tableContainer.innerHTML = '<p><i>Không có dữ liệu để hiển thị</i></p>';
      return;
    }

    let html = '<table><thead><tr>';
    html += '<th class="stt-col">STT</th>';
    headerCols.forEach(col => {
      html += `<th style="width:${col.width}%">${escapeHTML(col.text)}</th>`;
    });
    html += '</tr></thead><tbody>';

    for (let i=1; i<dataRows.length; i++) {
      const cells = dataRows[i].split("\t");
      html += '<tr>';
      html += `<td class="stt-col">${i}</td>`;
      for (let j=0; j<headerCols.length; j++) {
        html += `<td>${escapeHTML(cells[j] || '')}</td>`;
      }
      html += '</tr>';
    }

    html += '</tbody></table>';
    tableContainer.innerHTML = html;
  }

  // Hàm tạo ô tìm kiếm
  function createSearchInputs() {
    const container = document.getElementById("searchInputs");
    container.innerHTML = '';
    headerCols.forEach((col, idx) => {
      const input = document.createElement("input");
      input.type = "text";
      input.className = "search-box";
      input.placeholder = `Tìm kiếm ${col.text}`;
      input.dataset.colIndex = idx;
      input.addEventListener("input", onSearchInput);
      container.appendChild(input);
    });
  }

  // Hàm escape HTML để tránh lỗi hiển thị
  function escapeHTML(text) {
    return String(text)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  // Xử lý sự kiện nhập trong textbox tìm kiếm
  function onSearchInput() {
    const inputs = document.querySelectorAll("#searchInputs input.search-box");
    const filters = [];
    inputs.forEach(input => {
      const val = input.value.trim();
      filters.push(val);
    });

    // Lọc dữ liệu dựa trên regex, bất kỳ cột nào match là giữ
    // Nếu input rỗng thì bỏ qua
    const originalRows = window._originalData.trim().split(/\r?\n/);

    const filteredRows = [originalRows[0]]; // header luôn giữ

    for (let i=1; i<originalRows.length; i++) {
      const cols = originalRows[i].split("\t");
      let match = false;

      for (let j=0; j<filters.length; j++) {
        if (!filters[j]) continue;
        try {
          // Dùng regex ignore case
          const re = new RegExp(filters[j], "i");
          if (re.test(cols[j] || "")) {
            match = true;
            break; // chỉ cần match 1 cột là đủ
          }
        } catch(e) {
          // regex lỗi => coi như ko match
        }
      }

      if (match || filters.every(f => !f)) {
        filteredRows.push(originalRows[i]);
      }
    }

    renderTable(filteredRows);
  }

  // Khởi tạo lần đầu
  createSearchInputs();
  renderTable(rows);

})();
</script>
